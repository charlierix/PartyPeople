using Game.Core;
using Game.Core.Threads;
using Game.Math_WPF.Mathematics;
using Game.Math_WPF.WPF;
using Game.Math_WPF.WPF.Controls3D;
using Game.ML;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;

namespace Game.Bepu.Testers
{
    /// <summary>
    /// This looks at data generated by vr head and hands
    /// </summary>
    /// <remarks>
    /// It's difficult to find solutions that infer the body skeleton
    /// 
    /// Here's one
    /// https://github.com/JamesBear/vive_ik_demo
    /// 
    /// The head tracker sits in front of the face, so the first step is coming up with a good estimate for
    /// the location of the neck
    /// 
    /// From there, it might be useful to estimate the locations of the shoulders.  I guess it depends what
    /// the game wants this estimation for
    /// </remarks>
    public partial class AnalyzeVRPoints : Window
    {
        #region class: Snapshot

        private class Snapshot
        {
            public Snapshot(RecordingSnapshot snap)
            {
                Head_Pos = ToPoint(snap.Head_Pos);
                Head_Rot = ToQuat(snap.Head_Orientation);

                Left_Pos = ToPoint(snap.Left_Pos);
                Left_Rot = ToQuat(snap.Left_Orientation);

                Right_Pos = ToPoint(snap.Right_Pos);
                Right_Rot = ToQuat(snap.Right_Orientation);
            }

            public Point3D Head_Pos { get; }
            public Quaternion Head_Rot { get; }

            public Point3D Left_Pos { get; }
            public Quaternion Left_Rot { get; }

            public Point3D Right_Pos { get; }
            public Quaternion Right_Rot { get; }

            private static Point3D ToPoint(Vec3 v)
            {
                return new Point3D(v.x, v.y, v.z);
            }
            private static Quaternion ToQuat(Vec4 v)
            {
                return new Quaternion(v.x, v.y, v.z, v.w);
            }
        }

        #endregion

        #region Declaration Section

        /// <summary>
        /// Workers that call UtilityML.DiscoverSolution_CrossoverMutate will run on this thread
        /// </summary>
        /// <remarks>
        /// If the workers ran in their own threads, they would consume the threadpool, and the game would stutter
        /// </remarks>
        private readonly RoundRobinManager _crossoverkWorkerThread = new RoundRobinManager(new StaTaskScheduler(1));

        private TrackBallRoam _trackball = null;

        private Visual3D[] _axisVisual = null;

        private Visual3D _snapshotVisual = null;
        private Snapshot[] _snapshots = null;

        private string _filename = null;

        #endregion

        #region Constructor

        public AnalyzeVRPoints()
        {
            InitializeComponent();

            // Trackball
            _trackball = new TrackBallRoam(_camera);
            _trackball.EventSource = grdViewPort;       //NOTE:  If this control doesn't have a background color set, the trackball won't see events (I think transparent is ok, just not null)
            _trackball.AllowZoomOnMouseWheel = true;
            _trackball.Mappings.AddRange(TrackBallMapping.GetPrebuilt(TrackBallMapping.PrebuiltMapping.MouseComplete_NoLeft));
            _trackball.ShouldHitTestOnOrbit = false;
        }

        #endregion

        #region Event Listeners

        private void chkAxiis_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (chkAxiis == null)
                    return;

                if (!chkAxiis.IsChecked.Value)
                {
                    if (_axisVisual != null)
                    {
                        _viewport.Children.RemoveAll(_axisVisual);
                        _axisVisual = null;
                    }

                    return;
                }

                if (_axisVisual != null)
                    return;

                _axisVisual = Debug3DWindow.GetAxisLines(3, .005);
                _viewport.Children.AddRange(_axisVisual);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void Neck_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void Load_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                string folder = System.IO.Path.Combine(UtilityCore.GetOptionsFolder(), "VRFlight");

                // Prompt for file
                var dialog = new Microsoft.Win32.OpenFileDialog()
                {
                    InitialDirectory = folder,
                    //Filter = "*.xaml|*.xml|*.*",
                    Multiselect = false,
                };

                bool? result = dialog.ShowDialog();
                if (result == null || result.Value == false)
                {
                    return;
                }

                _filename = dialog.FileName;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void IsolateNeck_Click(object sender, RoutedEventArgs e)
        {
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                var options = new CrossoverMutate_Options<double>()
                {
                    GenerationSize = 1000,
                    MaxIterations = 50,
                    //ThreadShare = _crossoverkWorkerThread,
                    ScoreAscendDescend = new[] { false },
                    Predefined = new[]
                    {
                        new[] { .1, .1 },
                    },
                };

                var delegates = new CrossoverMutate_Delegates<double>()
                {
                    //GetNewSample = () => new double[] { StaticRandom.NextDouble(-MAX, MAX), StaticRandom.NextDouble(-MAX, MAX) },
                    GetNewSample = () => new double[] { StaticRandom.NextDouble(0, MAX), StaticRandom.NextDouble(0, MAX) },

                    GetScore = o => new[] { GetNeckDisplacementError(_snapshots, o) },

                    Mutate = o => MutateDisplacements(o, MAX),

                    FinalFound = o => ShowNeckResults(o),
                };

                UtilityML.DiscoverSolution_CrossoverMutate(delegates, options);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        private static double GetNeckDisplacementError(Snapshot[] snapshots, double[] settings)
        {
            Point3D[] necks = snapshots.
                Select(o => GetNeckPosition(o.Head_Pos, o.Head_Rot, settings[0], settings[1])).
                ToArray();

            Point3D center = Math3D.GetCenter(necks);

            double[] distances = necks.
                Select(o => (o - center).Length).
                ToArray();

            var avg_stddev = Math1D.Get_Average_StandardDeviation(distances);

            //TODO: May want to weight it using standard deviation
            return avg_stddev.avg;
        }

        private static double[] MutateDisplacements(double[] settings, double max)
        {
            double[] retVal = settings.ToArray();

            int index = StaticRandom.Next(settings.Length);

            retVal[index] = Math.Clamp(StaticRandom.NextPercent(retVal[index], .1), -max, max);

            return retVal;
        }

        private void ShowNeckResults(CrossoverMutate_Result<double> result)
        {
            Debug3DWindow window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(result.History.Select(o => o[0]).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {result.Score[0]}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", result.Item[0], result.Item[1]);
        }

        #region Private Methods

        private void LoadFile()
        {
            if (_filename == null || !System.IO.File.Exists(_filename))
                return;






            //TODO: Instead of guessing with textboxes, use ML to find the values with the least neck variance
            if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                neckBack = 0d;

            if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                neckDown = 0d;







            lblFilename.Content = System.IO.Path.GetFileName(_filename);

            string jsonString = System.IO.File.ReadAllText(_filename);

            SnapshotSet snapshot = JsonSerializer.Deserialize<SnapshotSet>(jsonString);

            var transformed = snapshot?.Snapshots?.
                Select(o => new Snapshot(o)).
                ToArray();

            Clear();
            Show(transformed, neckBack, neckDown);
            AnalyzePoints(transformed, neckBack, neckDown);
        }

        private void Clear()
        {
            if (_snapshotVisual != null)
            {
                _viewport.Children.Remove(_snapshotVisual);
                _snapshotVisual = null;
            }

            _snapshots = null;
        }
        private void Show(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            var mat = GetMaterials();

            Model3DGroup modelGroup = new Model3DGroup();

            foreach (var snapshot in snapshots)
            {
                AddDot(modelGroup, snapshot.Head_Pos, mat.head);
                AddDot(modelGroup, snapshot.Left_Pos, mat.left);
                AddDot(modelGroup, snapshot.Right_Pos, mat.right);

                AddNeckDot(modelGroup, snapshot.Head_Pos, snapshot.Head_Rot, mat.neck, neckBack, neckDown);
            }

            Visual3D visual = new ModelVisual3D
            {
                Content = modelGroup,
            };

            _snapshotVisual = visual;
            _viewport.Children.Add(visual);

            _snapshots = snapshots;
        }

        private void AddDot(Model3DGroup modelGroup, Point3D pos, Material mat)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(.02, 1, true);

            model.Transform = new TranslateTransform3D(pos.ToVector());

            modelGroup.Children.Add(model);
        }
        private void AddNeckDot(Model3DGroup modelGroup, Point3D pos, Quaternion rot, Material mat, double neckBack, double neckDown)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(.01, 1, true);

            Point3D finalPos = GetNeckPosition(pos, rot, neckBack, neckDown);

            model.Transform = new TranslateTransform3D(finalPos.ToVector());

            modelGroup.Children.Add(model);
        }

        private static (Material head, Material left, Material right, Material neck) GetMaterials()
        {
            MaterialGroup head = new MaterialGroup();
            head.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("92F32C")));
            //head.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex(""), ));

            MaterialGroup left = new MaterialGroup();
            left.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("269BAB")));
            left.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("503E7B"), 1));

            MaterialGroup right = new MaterialGroup();
            right.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("AB4726")));
            right.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("7B783E"), 1));

            MaterialGroup neck = new MaterialGroup();
            neck.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("EEE")));
            neck.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("FFF"), 4));

            return (head, left, right, neck);
        }

        private void AnalyzePoints(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            StringBuilder report = new StringBuilder();

            var headAABB = Math3D.GetAABB(snapshots.Select(o => o.Head_Pos));

            report.AppendLine("Head AABB");
            report.AppendLine($"x: {(headAABB.max.X - headAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(headAABB.max.Y - headAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(headAABB.max.Z - headAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var leftAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Left AABB");
            report.AppendLine($"x: {(leftAABB.max.X - leftAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(leftAABB.max.Y - leftAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(leftAABB.max.Z - leftAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var rightAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Right AABB");
            report.AppendLine($"x: {(rightAABB.max.X - rightAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(rightAABB.max.Y - rightAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(rightAABB.max.Z - rightAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            double error = GetNeckDisplacementError(snapshots, new[] { neckBack, neckDown });
            report.AppendLine($"neck err: {error.ToStringSignificantDigits(3)}");

            lblStats.Text = report.ToString();
        }

        private static Point3D GetNeckPosition(Point3D headPos, Quaternion headRot, double neckBack, double neckDown)
        {
            Vector3D up = headRot.GetRotatedVector(new Vector3D(0, 1, 0));
            Vector3D forword = headRot.GetRotatedVector(new Vector3D(0, 0, 1));

            Point3D finalPos = headPos;
            finalPos -= forword * neckBack;
            finalPos -= up * neckDown;

            return finalPos;
        }

        #endregion
    }

    #region classes: serialized

    [Serializable]
    public class SnapshotSet
    {
        public RecordingSnapshot[] Snapshots { get; set; }
    }

    [Serializable]
    public class RecordingSnapshot
    {
        public Vec3 Head_Pos { get; set; }
        public Vec4 Head_Orientation { get; set; }

        public Vec3 Left_Pos { get; set; }
        public Vec4 Left_Orientation { get; set; }

        public Vec3 Right_Pos { get; set; }
        public Vec4 Right_Orientation { get; set; }
    }

    [Serializable]
    public class Vec3
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
    }

    [Serializable]
    public class Vec4
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
        public float w { get; set; }
    }

    #endregion
}
