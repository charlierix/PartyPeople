using Game.Core;
using Game.Core.Threads;
using Game.Math_WPF.Mathematics;
using Game.Math_WPF.Mathematics.GeneticSharp;
using Game.Math_WPF.WPF;
using Game.Math_WPF.WPF.Controls3D;
using Game.Math_WPF.WPF.Viewers;
using Game.ML;
using GeneticSharp.Domain;
using GeneticSharp.Domain.Chromosomes;
using GeneticSharp.Domain.Crossovers;
using GeneticSharp.Domain.Fitnesses;
using GeneticSharp.Domain.Mutations;
using GeneticSharp.Domain.Populations;
using GeneticSharp.Domain.Selections;
using GeneticSharp.Domain.Terminations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;

namespace Game.Bepu.Testers
{
    /// <summary>
    /// This looks at data generated by vr head and hands
    /// </summary>
    /// <remarks>
    /// It's difficult to find solutions that infer the body skeleton
    /// 
    /// Here's one
    /// https://github.com/JamesBear/vive_ik_demo
    /// 
    /// The head tracker sits in front of the face, so the first step is coming up with a good estimate for
    /// the location of the neck
    /// 
    /// From there, it might be useful to estimate the locations of the shoulders.  I guess it depends what
    /// the game wants this estimation for
    /// </remarks>
    public partial class AnalyzeVRPoints : Window
    {
        #region class: Snapshot

        private class Snapshot
        {
            public Snapshot(RecordingSnapshot snap)
            {
                Head_Pos = Vec3.ToPoint(snap.Head_Pos);
                Head_Rot = Vec4.ToQuat(snap.Head_Orientation);

                Left_Pos = Vec3.ToPoint(snap.Left_Pos);
                Left_Rot = Vec4.ToQuat(snap.Left_Orientation);

                Right_Pos = Vec3.ToPoint(snap.Right_Pos);
                Right_Rot = Vec4.ToQuat(snap.Right_Orientation);
            }

            public Point3D Head_Pos { get; }
            public Quaternion Head_Rot { get; }

            public Point3D Left_Pos { get; }
            public Quaternion Left_Rot { get; }

            public Point3D Right_Pos { get; }
            public Quaternion Right_Rot { get; }

            public Point3D GetNeckPosition(double neckBack, double neckDown)
            {
                Vector3D up = Head_Rot.GetRotatedVector(new Vector3D(0, 1, 0));
                Vector3D forword = Head_Rot.GetRotatedVector(new Vector3D(0, 0, 1));

                Point3D finalPos = Head_Pos;
                finalPos -= forword * neckBack;
                finalPos -= up * neckDown;

                return finalPos;
            }
        }

        #endregion
        #region class: HandPlane

        private class HandPlane
        {
            public string Name { get; set; }
            public Snapshot[] Snapshots { get; set; }
            public bool IsLeft { get; set; }
            public Point3D[] Points { get; set; }
            public ITriangle_wpf Plane { get; set; }
            public string DotColor { get; set; } = "888";
            public string PlaneColor { get; set; } = "888";
        };

        #endregion

        #region Declaration Section

        private const double DOTRADIUS = .02;
        private const string COLOR_LEFT = "269BAB";
        private const string COLOR_RIGHT = "AB4726";

        /// <summary>
        /// Workers that call UtilityML.DiscoverSolution_CrossoverMutate will run on this thread
        /// </summary>
        /// <remarks>
        /// If the workers ran in their own threads, they would consume the threadpool, and the game would stutter
        /// </remarks>
        private readonly RoundRobinManager _crossoverkWorkerThread = new RoundRobinManager(new StaTaskScheduler(1));

        private TrackBallRoam _trackball = null;

        private Visual3D[] _axisVisual = null;

        private List<Visual3D> _visuals = new List<Visual3D>();
        private Snapshot[] _snapshots = null;

        private string[] _filenames = null;

        private bool _initialized = false;

        #endregion

        #region Constructor

        public AnalyzeVRPoints()
        {
            InitializeComponent();

            // Trackball
            _trackball = new TrackBallRoam(_camera);
            _trackball.EventSource = grdViewPort;       //NOTE:  If this control doesn't have a background color set, the trackball won't see events (I think transparent is ok, just not null)
            _trackball.AllowZoomOnMouseWheel = true;
            _trackball.Mappings.AddRange(TrackBallMapping.GetPrebuilt(TrackBallMapping.PrebuiltMapping.MouseComplete_NoLeft));
            _trackball.ShouldHitTestOnOrbit = false;
            _trackball.MouseWheelScale *= .3;

            _initialized = true;

            chkAxiis_Checked(this, new RoutedEventArgs());
        }

        #endregion

        #region Event Listeners

        private void chkAxiis_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                if (!chkAxiis.IsChecked.Value)
                {
                    if (_axisVisual != null)
                    {
                        _viewport.Children.RemoveAll(_axisVisual);
                        _axisVisual = null;
                    }

                    return;
                }

                if (_axisVisual != null)
                    return;

                _axisVisual = Debug3DWindow.GetAxisLines(3, .005);
                _viewport.Children.AddRange(_axisVisual);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void chCenterOnNeck_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void Neck_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void Load_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                string[] filenames = PromptForFilenames();
                if (filenames == null || filenames.Length == 0)
                    return;

                _filenames = filenames;
                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void IsolateNeck1_Click(object sender, RoutedEventArgs e)
        {
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                var options = new CrossoverMutate_Options<double>()
                {
                    GenerationSize = 1000,
                    MaxIterations = 50,
                    //ThreadShare = _crossoverkWorkerThread,
                    ScoreAscendDescend = new[] { false },
                    Predefined = new[]
                    {
                        new[] { .1, .1 },
                    },
                };

                var delegates = new CrossoverMutate_Delegates<double>()
                {
                    //GetNewSample = () => new double[] { StaticRandom.NextDouble(-MAX, MAX), StaticRandom.NextDouble(-MAX, MAX) },
                    GetNewSample = () => new double[] { StaticRandom.NextDouble(0, MAX), StaticRandom.NextDouble(0, MAX) },

                    GetScore = o => new[] { GetNeckDisplacementError(_snapshots, o) },

                    Mutate = o => MutateDisplacements(o, MAX),

                    FinalFound = o => ShowNeckResults(o),
                };

                UtilityML.DiscoverSolution_CrossoverMutate(delegates, options);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void IsolateNeck3_Click(object sender, RoutedEventArgs e)
        {
            const double MULT = 10000d;
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                //TODO: Figure out how to deal directly with fractions (how many bits to use)
                int bits = GeneticSharpUtil.GetChromosomeBits((MAX * MULT).ToInt_Ceiling(), 0);

                // Element0 = Neck Back
                // Element1 = Neck Down
                var chromosome = new FloatingPointChromosome(
                    new double[] { 0, 0 },
                    new double[] { MAX * MULT, MAX * MULT },
                    new int[] { bits, bits },       // The total bits used to represent each number
                    new int[] { 0, 0 });      // The number of fraction (scale or decimal) part of the number. In our case we will not use any

                var population = new Population(72, 144, chromosome);

                double worstScore = MAX * Math.Sqrt(2);
                worstScore += MAX;      // add a bit to be safe

                var fitness = new FuncFitness(c =>
                {
                    double[] values = ((FloatingPointChromosome)c).ToFloatingPoints();

                    for (int cntr = 0; cntr < values.Length; cntr++)
                        values[cntr] /= MULT;       // the values are stored as integers, because I haven't figured out how many bits to use for floating point yet

                    return worstScore - GetNeckDisplacementError(_snapshots, values);       // subtracting because this needs to return a top score when error is zero
                });

                var selection = new EliteSelection();       // the higher the score, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0.0;
                var winners = new List<(double, double[])>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        winners.Add(
                        (
                            latestFitness,
                            bestChromosome.ToFloatingPoints().
                                Select(o => o / MULT).
                                ToArray()
                        ));
                    }
                };

                ga.TerminationReached += (s2, e2) => ShowNeckResults(winners, worstScore);

                ga.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        //TODO: Each hand needs its own plane
        private void CalculatePlane1_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                bool centerOnNeck = chkCenterOnNeck.IsChecked.Value;

                string left = CalculateShowPlane(_snapshots.Select(o => o.Left_Pos), UtilityWPF.ColorFromHex(COLOR_LEFT), centerOnNeck);
                string right = CalculateShowPlane(_snapshots.Select(o => o.Right_Pos), UtilityWPF.ColorFromHex(COLOR_RIGHT), centerOnNeck);

                lblPlane.Text = $"Left\r\n{left}\r\nRight{right}";
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void CalculatePlane2_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                Point3D[] points = _snapshots.
                    Select(o => o.Left_Pos).
                    ToArray();

                var planes = Enumerable.Range(0, 144).
                    AsParallel().
                    Select(o =>
                    {
                        var plane = Math2D.GetPlane_Average(points);

                        if (Vector3D.DotProduct(plane.Normal, new Vector3D(0, 1, 0)) < 0)
                            return new Triangle_wpf(plane.Point0, plane.Point2, plane.Point1);      // reversing the vertex order
                        else
                            return plane;
                    }).
                    ToArray();

                Vector3D avgNormal = Math3D.GetAverage(planes.Select(o => o.NormalUnit));

                var dots = planes.
                    Select(o => new
                    {
                        plane = o,
                        dot = Vector3D.DotProduct(o.NormalUnit, avgNormal),
                    }).
                    OrderBy(o => o.dot).
                    ToArray();


                foreach (var plane in dots.Take(1))
                {
                    ImprovePlane(plane.plane, points, 12);
                }

                //foreach (var plane in dots.TakeLast(2))
                //{
                //    ImprovePlane(plane.plane, points);
                //}
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void CalculatePlane3_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // 2 failed because the corrected plane didn't try to minimize the sum of the distance from the plane

                // it would be kind of fun to try a genetic algorithm, even though it's probably not optimal

                // the code in math2d chooses completely random triangles and averages them with equal weight, but should really
                // give a lot more importance to the largest triangles, or throw out tiny triangles completely (based on the length
                // of the normals)
                //
                // but what's a good way to choose the points that are likely to give large areas?
                //    once one vertex is chosen, choose another that is at least X away?
                //    choose a bunch of random like it currently does, look at the distribution of areas, decide on a threshold, keep choosing until a count is met?

                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                Point3D[] points = _snapshots.
                    Select(o => o.Left_Pos).
                    ToArray();

                Point3D center = Math3D.GetCenter(points);

                var aabb = Math3D.GetAABB(points);

                var chromosome = FloatingPointChromosome2.Create(
                    new double[] { aabb.min.X, aabb.min.Y, aabb.min.Z, -12, -12, -12 },
                    new double[] { aabb.max.X, aabb.max.Y, aabb.max.Z, 12, 12, 12 },
                    new int[]
                    {
                        GeneticSharpUtil.GetNumDecimalPlaces(3, aabb.min.X, aabb.max.X),
                        GeneticSharpUtil.GetNumDecimalPlaces(3, aabb.min.Y, aabb.max.Y),
                        GeneticSharpUtil.GetNumDecimalPlaces(3, aabb.min.Z, aabb.max.Z),
                        5,
                        5,
                        5,
                    },
                    new double[] { center.X, center.Y, center.Z, 0, 0, 1 });

                var population = new Population(72, 144, chromosome);

                double maxError = ((aabb.max - aabb.min).Length * points.Length) * 1.5;

                var fitness = new FuncFitness(c =>
                {
                    var fc = c as FloatingPointChromosome2;
                    var values = fc.ToFloatingPoints();

                    var plane = Math3D.GetPlane(new Point3D(values[0], values[1], values[2]), new Vector3D(values[3], values[4], values[5]));
                    double error = points.Sum(o => Math.Abs(Math3D.DistanceFromPlane(plane, o)));

                    if (error > maxError)
                        throw new ApplicationException("we're going to need a bigger boat");

                    return maxError - error;       // need to return in a format where largest value wins
                });

                var selection = new EliteSelection();       // the larger the score, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0;
                var winners = new List<(double score, double[] values)>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome2;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        double[] phenotype = bestChromosome.ToFloatingPoints();
                        winners.Add((latestFitness, phenotype));
                    }
                };

                ga.Start();

                ShowWinningPlanes(winners, points);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void PlanesAcrossFiles_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                string[] filenames = PromptForFilenames();
                if (filenames == null || filenames.Length == 0)
                    return;

                if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                    neckBack = 0d;

                if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                    neckDown = 0d;

                #region get breakdowns

                var snapshots = filenames.
                    Select(o => new
                    {
                        filename = o,
                        snapshots = LoadSnapshots(o),
                    }).
                    Where(o => o.snapshots != null && o.snapshots.Length > 3).
                    ToArray();

                // Get the plane for each hand of each snapshot set
                var breakdowns = snapshots.
                    SelectMany(o => new[]
                    {
                        new HandPlane()
                        {
                            Name = o.filename,
                            Snapshots = o.snapshots,
                            IsLeft = true,
                            Points = o.snapshots.
                                Select(p => p.Left_Pos).
                                ToArray(),
                        },
                        new HandPlane()
                        {
                            Name = o.filename,
                            Snapshots = o.snapshots,
                            IsLeft = false,
                            Points = o.snapshots.
                                Select(p => p.Right_Pos).
                                ToArray(),
                        },
                    }).
                    AsParallel().
                    Select(o => new HandPlane()
                    {
                        Name = o.Name,
                        Snapshots = o.Snapshots,
                        IsLeft = o.IsLeft,
                        Points = o.Points,
                        Plane = Math2D.GetPlane_Average(o.Points),
                    }).
                    ToArray();

                #endregion

                // Show everything together - no total average
                ShowHandPlanes("left - gray", breakdowns.Where(o => o.IsLeft).ToArray(), false);
                ShowHandPlanes("right - gray", breakdowns.Where(o => !o.IsLeft).ToArray(), false);

                ShowHandPlanes("left - unique colors", breakdowns.Where(o => o.IsLeft).ToArray(), true);
                ShowHandPlanes("right - unique colors", breakdowns.Where(o => !o.IsLeft).ToArray(), true);

                // Show everything together - with total average
                var summaryLeft = new HandPlane()
                {
                    Name = "Summary Left",
                    PlaneColor = "F00",
                    //Plane = Math2D.GetPlane_Average(breakdowns.Where(o => o.IsLeft).SelectMany(o => o.Points).ToArray())
                    Plane = GetAveragePlane(breakdowns.Where(o => o.IsLeft).Select(o => o.Plane).ToArray()),
                };

                var summaryRight = new HandPlane()
                {
                    Name = "Summary Right",
                    PlaneColor = "F00",
                    //Plane = Math2D.GetPlane_Average(breakdowns.Where(o => !o.IsLeft).SelectMany(o => o.Points).ToArray())
                    Plane = GetAveragePlane(breakdowns.Where(o => !o.IsLeft).Select(o => o.Plane).ToArray()),
                };

                ShowHandPlanes("left - summary", breakdowns.Where(o => o.IsLeft).Concat(new[] { summaryLeft }).ToArray(), false);
                ShowHandPlanes("right - summary", breakdowns.Where(o => !o.IsLeft).Concat(new[] { summaryRight }).ToArray(), false);

                // Each hand should be a perfect mirror, show how left and right trend differently (account for the mirroring)
                AnalyzeMirrorPlanes(breakdowns, summaryLeft.Plane, summaryRight.Plane, neckBack, neckDown);

                #region report

                StringBuilder report = new StringBuilder();

                report.AppendLine("Left Average:");
                report.AppendLine($"pos: {summaryLeft.Plane.GetCenterPoint().ToStringSignificantDigits(4)}");
                report.AppendLine($"norm: {summaryLeft.Plane.NormalUnit}");

                report.AppendLine();

                report.AppendLine("Right Average:");
                report.AppendLine($"pos: {summaryRight.Plane.GetCenterPoint().ToStringSignificantDigits(4)}");
                report.AppendLine($"norm: {summaryRight.Plane.NormalUnit}");

                lblPlanesAcrossFiles.Text = report.ToString();

                #endregion
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Private Methods

        private void LoadFile()
        {
            if (_filenames == null || _filenames.Length == 0 || _filenames.Any(o => !System.IO.File.Exists(o)))
                return;

            if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                neckBack = 0d;

            if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                neckDown = 0d;

            lblFilename.Content = _filenames.
                Select(o => System.IO.Path.GetFileName(o)).
                ToJoin("\r\n");

            var snapshots = new List<Snapshot>();

            foreach (string filename in _filenames)
            {
                var snapshots1 = LoadSnapshots(filename);

                if (snapshots1 != null)
                    snapshots.AddRange(snapshots1);
            }

            Clear();
            Show(snapshots.ToArray(), neckBack, neckDown, chkCenterOnNeck.IsChecked.Value);
            AnalyzePoints(snapshots.ToArray(), neckBack, neckDown);
        }

        private void Clear()
        {
            _viewport.Children.RemoveAll(_visuals);
            _visuals.Clear();

            _snapshots = null;
        }
        private void Show(Snapshot[] snapshots, double neckBack, double neckDown, bool handsOffNeck)
        {
            var mat = GetMaterials();

            Model3DGroup modelGroup = new Model3DGroup();

            Point3D avgNeck = handsOffNeck ?
                Math3D.GetCenter(snapshots.Select(o => o.GetNeckPosition(neckBack, neckDown))) :
                new Point3D();

            foreach (var snapshot in snapshots)
            {
                Point3D neckPos = snapshot.GetNeckPosition(neckBack, neckDown);

                if (handsOffNeck)
                {
                    AddDot(modelGroup, avgNeck + (snapshot.Head_Pos - neckPos), mat.head);
                    AddDot(modelGroup, avgNeck + (snapshot.Left_Pos - neckPos), mat.left);
                    AddDot(modelGroup, avgNeck + (snapshot.Right_Pos - neckPos), mat.right);
                    AddDot(modelGroup, avgNeck + (neckPos - neckPos), mat.neck, .5);
                }
                else
                {
                    AddDot(modelGroup, snapshot.Head_Pos, mat.head);
                    AddDot(modelGroup, snapshot.Left_Pos, mat.left);
                    AddDot(modelGroup, snapshot.Right_Pos, mat.right);
                    AddDot(modelGroup, neckPos, mat.neck, .5);
                }
            }

            Visual3D visual = new ModelVisual3D
            {
                Content = modelGroup,
            };

            _visuals.Add(visual);
            _viewport.Children.Add(visual);

            _snapshots = snapshots;
        }

        private void AddDot(Model3DGroup modelGroup, Point3D pos, Material mat, double radiusPercent = 1)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(DOTRADIUS * radiusPercent, 1, true);

            model.Transform = new TranslateTransform3D(pos.ToVector());

            modelGroup.Children.Add(model);
        }

        private static (Material head, Material left, Material right, Material neck) GetMaterials()
        {
            MaterialGroup head = new MaterialGroup();
            head.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("92F32C")));
            //head.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex(""), ));

            MaterialGroup left = new MaterialGroup();
            left.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex(COLOR_LEFT)));
            left.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("503E7B"), 1));

            MaterialGroup right = new MaterialGroup();
            right.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex(COLOR_RIGHT)));
            right.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("7B783E"), 1));

            MaterialGroup neck = new MaterialGroup();
            neck.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("EEE")));
            neck.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("FFF"), 4));

            return (head, left, right, neck);
        }

        private void AnalyzePoints(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            StringBuilder report = new StringBuilder();

            var headAABB = Math3D.GetAABB(snapshots.Select(o => o.Head_Pos));

            report.AppendLine("Head AABB");
            report.AppendLine($"x: {(headAABB.max.X - headAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(headAABB.max.Y - headAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(headAABB.max.Z - headAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var leftAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Left AABB");
            report.AppendLine($"x: {(leftAABB.max.X - leftAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(leftAABB.max.Y - leftAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(leftAABB.max.Z - leftAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var rightAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Right AABB");
            report.AppendLine($"x: {(rightAABB.max.X - rightAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(rightAABB.max.Y - rightAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(rightAABB.max.Z - rightAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            double error = GetNeckDisplacementError(snapshots, new[] { neckBack, neckDown });
            report.AppendLine($"neck err: {error.ToStringSignificantDigits(3)}");

            lblStats.Text = report.ToString();
        }

        private static double GetNeckDisplacementError(Snapshot[] snapshots, double[] settings)
        {
            Point3D[] necks = snapshots.
                Select(o => o.GetNeckPosition(settings[0], settings[1])).
                ToArray();

            Point3D center = Math3D.GetCenter(necks);

            double[] distances = necks.
                Select(o => (o - center).Length).
                ToArray();

            var avg_stddev = Math1D.Get_Average_StandardDeviation(distances);

            //TODO: May want to weight it using standard deviation
            return avg_stddev.avg;
        }
        private static double[] MutateDisplacements(double[] settings, double max)
        {
            double[] retVal = settings.ToArray();

            int index = StaticRandom.Next(settings.Length);

            retVal[index] = Math.Clamp(StaticRandom.NextPercent(retVal[index], .1), -max, max);

            return retVal;
        }
        private void ShowNeckResults(CrossoverMutate_Result<double> result)
        {
            var window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(result.History.Select(o => o[0]).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {result.Score[0]}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", result.Item[0], result.Item[1]);
        }
        private void ShowNeckResults(List<(double, double[])> log, double worstScore)
        {
            var window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(log.Select(o => worstScore - o.Item1).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {worstScore - log[^1].Item1}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", log[^1].Item2[0], log[^1].Item2[1]);
        }

        private string CalculateShowPlane(IEnumerable<Point3D> points, Color color, bool centerOnNeck)
        {
            // Get Points
            Point3D[] points1 = null;
            if (centerOnNeck)
            {
                if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                    neckBack = 0d;

                if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                    neckDown = 0d;

                Point3D avgNeck = Math3D.GetCenter(_snapshots.Select(o => o.GetNeckPosition(neckBack, neckDown)));

                points1 = points.
                    Select((o, i) =>
                    {
                        Point3D neckPos = _snapshots[i].GetNeckPosition(neckBack, neckDown);
                        return avgNeck + (o - neckPos);
                    }).
                    ToArray();
            }
            else
            {
                points1 = points.ToArray();
            }

            // Show Plane
            var plane = Math2D.GetPlane_Average(points1);
            Point3D pointOnPlane = Math3D.GetClosestPoint_Plane_Point(plane, Math3D.GetCenter(points1));

            Visual3D visual = Debug3DWindow.GetPlane(plane, 3, color, center: pointOnPlane);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            visual = Debug3DWindow.GetDot(pointOnPlane, DOTRADIUS * 1.5, color);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            visual = Debug3DWindow.GetLine(pointOnPlane, pointOnPlane + plane.NormalUnit, DOTRADIUS / 3, color);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            // Report
            StringBuilder report = new StringBuilder();
            report.AppendLine($"Normal: {plane.NormalUnit.ToStringSignificantDigits(3)}");
            report.AppendLine($"Point: {pointOnPlane.ToStringSignificantDigits(3)}");

            return report.ToString();
        }

        private static ITriangle_wpf ImprovePlane(ITriangle_wpf plane, Point3D[] points, int countdown)
        {
            var pointDistances = points.
                Select(o => new
                {
                    point = o,
                    dist = Math.Abs(Math3D.DistanceFromPlane(plane, o)),
                }).
                ToArray();

            double maxDist = pointDistances.Max(o => o.dist);

            Point3D center = Math3D.GetCenter(points);

            var sizes = Debug3DWindow.GetDrawSizes(Math3D.GetAABB(points).max.ToVector3().Length());

            #region draw initial

            var window = new Debug3DWindow()
            {
                Title = countdown.ToString(),
                Width = 1000,
                Height = 1000,
            };

            window.AddAxisLines(2, sizes.line);

            foreach (var point in pointDistances)
            {
                double percent = UtilityMath.GetScaledValue_Capped(0, 1, 0, maxDist, point.dist);
                Color color = UtilityWPF.AlphaBlend(Colors.Red, Colors.White, percent);

                window.AddDot(point.point, sizes.dot, color);
            }

            window.AddDot(center, sizes.dot, Colors.Black);

            window.AddPlane(plane, 2, Colors.Coral);

            window.Show();

            #endregion

            var offsets = points.
                Select(o =>
                {
                    Point3D planePoint = Math3D.GetClosestPoint_Plane_Point(plane, o);
                    //Quaternion rotation = Math3D.GetRotation(o - center, planePoint - center);
                    Quaternion rotation = Math3D.GetRotation(o - center, planePoint - center);

                    return new
                    {
                        point = o,
                        planePoint,
                        //rotation = rotation.ToUnit(),
                        rotation,
                    };
                }).
                ToArray();

            Quaternion average = Math3D.GetAverage(offsets.Select(o => o.rotation).ToArray());

            Vector3D planeNormal = plane.NormalUnit;

            #region draw quats

            window = new Debug3DWindow()
            {
                Title = "Rotations",
                Width = 1000,
                Height = 1000,
            };

            window.AddLines
            (
                offsets.
                    Select(o =>
                    (
                        center,
                        center + o.rotation.GetRotatedVector(planeNormal)
                    )),
                sizes.line,
                Colors.Black
            );

            window.AddLine(center, center + average.GetRotatedVector(planeNormal * 1.1), sizes.line, Colors.White);

            window.AddLine(center, center + planeNormal * 1.1, sizes.line, Colors.Red);

            //window.Show();

            #endregion

            var plane2 = Math3D.GetPlane(center, average.GetRotatedVector(plane.NormalUnit));

            return countdown > 0 ?
                ImprovePlane(plane2, points, countdown - 1) :
                plane2;
        }

        private static void ShowWinningPlanes(List<(double score, double[] values)> winners, Point3D[] points)
        {
            var sizes = Debug3DWindow.GetDrawSizes(Math3D.GetAABB(points).max.ToVector3().Length());

            Point3D center = Math3D.GetCenter(points);

            foreach (var set in winners.Take(2).Concat(winners.TakeLast(2)))
            {
                var plane = Math3D.GetPlane(new Point3D(set.values[0], set.values[1], set.values[2]), new Vector3D(set.values[3], set.values[4], set.values[5]));

                var pointDistances = points.
                    Select(o => new
                    {
                        point = o,
                        dist = Math.Abs(Math3D.DistanceFromPlane(plane, o)),
                    }).
                    ToArray();

                double maxDist = pointDistances.Max(o => o.dist);

                var window = new Debug3DWindow()
                {
                    Title = set.score.ToString(),
                };

                window.AddAxisLines(2, sizes.line);

                foreach (var point in pointDistances)
                {
                    double percent = UtilityMath.GetScaledValue_Capped(0, 1, 0, maxDist, point.dist);
                    Color color = UtilityWPF.AlphaBlend(Colors.Red, Colors.White, percent);

                    window.AddDot(point.point, sizes.dot, color);
                }

                window.AddDot(center, sizes.dot, Colors.Black);

                window.AddPlane(plane, 2, Colors.Coral, center: Math3D.GetClosestPoint_Plane_Point(plane, center));

                window.Show();
            }
        }

        private static string[] PromptForFilenames()
        {
            string folder = System.IO.Path.Combine(UtilityCore.GetOptionsFolder(), "VRFlight");

            // Prompt for file
            var dialog = new Microsoft.Win32.OpenFileDialog()
            {
                InitialDirectory = folder,
                //Filter = "*.xaml|*.xml|*.*",
                Multiselect = true,
            };

            bool? result = dialog.ShowDialog();
            if (result == null || result.Value == false)
            {
                return null;
            }

            return dialog.FileNames;
        }

        private static Snapshot[] LoadSnapshots(string filename)
        {
            string jsonString = System.IO.File.ReadAllText(filename);

            SnapshotSet snapshot = JsonSerializer.Deserialize<SnapshotSet>(jsonString);

            return snapshot?.Snapshots?.
                Select(o => new Snapshot(o)).
                ToArray();
        }

        private static void ShowHandPlanes(string title, HandPlane[] planes, bool randomColors)
        {
            if (randomColors)
            {
                planes = planes.
                    Select(o =>
                    {
                        string color = StaticRandom.GetRandomForThread().ColorHSV().ToHex(false, false);
                        return new HandPlane()
                        {
                            Name = o.Name,
                            Snapshots = o.Snapshots,
                            IsLeft = o.IsLeft,
                            Points = o.Points,
                            Plane = o.Plane,
                            DotColor = color,
                            PlaneColor = color,
                        };
                    }).
                    ToArray();
            }

            var sizes = Debug3DWindow.GetDrawSizes(3);

            var window = new Debug3DWindow()
            {
                Title = title,
            };

            window.AddAxisLines(2, sizes.line);

            foreach (var byDotColor in planes.ToLookup(o => o.DotColor))
            {
                window.AddDots(byDotColor.Where(o => o.Points != null && o.Points.Length > 0).SelectMany(o => o.Points), sizes.dot, UtilityWPF.ColorFromHex(byDotColor.Key));
            }

            foreach (HandPlane plane in planes)
            {
                window.AddPlane(plane.Plane, 2, UtilityWPF.ColorFromHex(plane.PlaneColor));
            }

            window.Show();
        }

        private static ITriangle_wpf GetAveragePlane(ITriangle_wpf[] planes)
        {
            Vector3D[] normals = planes.
                Select(o => o.NormalUnit).
                ToArray();

            for (int cntr = 1; cntr < normals.Length; cntr++)
            {
                if (Vector3D.DotProduct(normals[0], normals[cntr]) < 0)
                    normals[cntr] = -normals[cntr];
            }

            Vector3D averageNormal = Math3D.GetAverage(normals).ToUnit();

            // Not sure if it's better to average the center points, or average the nearest points to origin
            Point3D[] centersAbs = planes.
                Select(o => o.GetCenterPoint()).
                ToArray();

            Point3D centerAbs = Math3D.GetCenter(centersAbs);



            // The planes are almost identical, but not quite.  I trust the average center point more, because there's less chance of drift
            //Point3D[] relativeOrigins = planes.
            //    Select(o => Math3D.GetClosestPoint_Plane_Point(o, new Point3D())).
            //    ToArray();

            //Point3D centerRelativeOrigin = Math3D.GetCenter(relativeOrigins);


            //var sizes = Debug3DWindow.GetDrawSizes(4);
            //var window = new Debug3DWindow();

            //window.AddDots(centersAbs, sizes.dot, Colors.Black);
            //window.AddDot(centerAbs, sizes.dot, Colors.Blue);
            //window.AddPlane(Math3D.GetPlane(centerAbs, averageNormal), 1, Colors.Blue);

            //window.AddDots(relativeOrigins, sizes.dot, Colors.White);
            //window.AddDot(centerRelativeOrigin, sizes.dot, Colors.Aquamarine);
            //window.AddPlane(Math3D.GetPlane(centerRelativeOrigin, averageNormal), 1, Colors.Aquamarine);

            //window.Show();



            return Math3D.GetPlane(centerAbs, averageNormal);
        }

        private static void AnalyzeMirrorPlanes(HandPlane[] hands, ITriangle_wpf avgLeft, ITriangle_wpf avgRight, double neckBack, double neckDown)
        {
            Point3D[] necks = hands.
                SelectMany(o => o.Snapshots).
                Select(o => o.GetNeckPosition(neckBack, neckDown)).
                ToArray();

            Point3D avgNeck = Math3D.GetCenter(necks);

            Point3D leftPos = avgLeft.GetCenterPoint();
            Point3D rightPos = avgRight.GetCenterPoint();


            Vector3D leftToRight = rightPos - leftPos;

            //Point3D center = leftPos + (leftToRight * .5);
            Point3D center = avgNeck - new Vector3D(0, 1, 0);

            Vector3D neckToCenter = center - avgNeck;

            Vector3D handsCrossSpine = Vector3D.CrossProduct(leftToRight, neckToCenter);

            var mirrorPlane = new Triangle_wpf(avgNeck, center, center + handsCrossSpine);

            #region draw actual

            var sizes = Debug3DWindow.GetDrawSizes(2);

            var window = new Debug3DWindow()
            {
                Title = "Mirror",
            };

            window.AddAxisLines(3, sizes.line);

            window.AddDots(necks, sizes.dot / 4, Colors.White);
            window.AddDot(avgNeck, sizes.dot, Colors.White);
            window.AddPlane(mirrorPlane, 2, Colors.White, center: center);

            window.AddPlane(avgLeft, 3, Colors.DarkOrange);
            window.AddDot(leftPos, sizes.dot, Colors.DarkOrange);
            window.AddLine(leftPos - avgLeft.NormalUnit, leftPos + avgLeft.NormalUnit, sizes.line, Colors.DarkOrange);

            window.AddPlane(avgRight, 3, Colors.DarkCyan);
            window.AddDot(rightPos, sizes.dot, Colors.DarkCyan);
            window.AddLine(rightPos - avgRight.NormalUnit, rightPos + avgRight.NormalUnit, sizes.line, Colors.DarkCyan);

            window.AddLine(avgNeck, center, sizes.line, Colors.Gray);
            window.AddLine(leftPos, rightPos, sizes.line, Colors.Gray);

            window.Show();

            #endregion



            // Figure out where right position would be if reflected off the white plane over to the left side (by definition, it's the same position, unless you compare with xz plane)
            // Also reflect right's normal

            // Then draw left and right on top of each other


            Vector3D rightProjected = avgRight.NormalUnit.GetProjectedVector(mirrorPlane);

            Quaternion rightToMirror = Math3D.GetRotation(avgRight.NormalUnit, rightProjected);

            Vector3D rightNormalMirrored = rightToMirror.GetRotatedVector(avgRight.NormalUnit);       //TODO: Instead of applying the rotation twice, see if the quaternion can be multiplied by 2
            rightNormalMirrored = rightToMirror.GetRotatedVector(rightNormalMirrored);

            Point3D rightPosMirrored = Math3D.GetClosestPoint_Plane_Point(mirrorPlane, rightPos);
            rightPosMirrored += rightPosMirrored - rightPos;

            var planeRightMirror = Math3D.GetPlane(rightPosMirrored, rightNormalMirrored);


            #region draw reflected

            window = new Debug3DWindow()
            {
                Title = "Reflected",
            };

            window.AddAxisLines(3, sizes.line);

            window.AddDot(avgNeck, sizes.dot, Colors.White);
            window.AddPlane(mirrorPlane, 2, Colors.White, center: center);


            window.AddPlane(avgLeft, 3, Colors.DarkOrange);
            window.AddDot(leftPos, sizes.dot, Colors.DarkOrange);
            window.AddLine(leftPos - avgLeft.NormalUnit, leftPos + avgLeft.NormalUnit, sizes.line, Colors.DarkOrange);

            window.AddPlane(planeRightMirror, 3, Colors.DarkCyan);
            window.AddDot(rightPosMirrored, sizes.dot, Colors.DarkCyan);
            window.AddLine(rightPosMirrored - rightNormalMirrored, rightPosMirrored + rightNormalMirrored, sizes.line, Colors.DarkCyan);

            window.AddLine(avgNeck, center, sizes.line, Colors.Gray);
            window.AddLine(leftPos, Math3D.GetClosestPoint_Plane_Point(mirrorPlane, leftPos), sizes.line, Colors.Gray);
            window.AddLine(rightPosMirrored, Math3D.GetClosestPoint_Plane_Point(mirrorPlane, rightPosMirrored), sizes.line, Colors.Gray);

            window.Show();

            #endregion


        }

        #endregion
    }

    #region classes: serialized

    [Serializable]
    public class SnapshotSet
    {
        public RecordingSnapshot[] Snapshots { get; set; }
    }

    [Serializable]
    public class RecordingSnapshot
    {
        public Vec3 Head_Pos { get; set; }
        public Vec4 Head_Orientation { get; set; }

        public Vec3 Left_Pos { get; set; }
        public Vec4 Left_Orientation { get; set; }

        public Vec3 Right_Pos { get; set; }
        public Vec4 Right_Orientation { get; set; }
    }

    // The rest is in SerializedForUnity.cs

    #endregion
}
