using Game.Core;
using Game.Core.Threads;
using Game.Math_WPF.Mathematics;
using Game.Math_WPF.WPF;
using Game.Math_WPF.WPF.Controls3D;
using Game.ML;
using GeneticSharp.Domain;
using GeneticSharp.Domain.Chromosomes;
using GeneticSharp.Domain.Crossovers;
using GeneticSharp.Domain.Fitnesses;
using GeneticSharp.Domain.Mutations;
using GeneticSharp.Domain.Populations;
using GeneticSharp.Domain.Selections;
using GeneticSharp.Domain.Terminations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;

namespace Game.Bepu.Testers
{
    /// <summary>
    /// This looks at data generated by vr head and hands
    /// </summary>
    /// <remarks>
    /// It's difficult to find solutions that infer the body skeleton
    /// 
    /// Here's one
    /// https://github.com/JamesBear/vive_ik_demo
    /// 
    /// The head tracker sits in front of the face, so the first step is coming up with a good estimate for
    /// the location of the neck
    /// 
    /// From there, it might be useful to estimate the locations of the shoulders.  I guess it depends what
    /// the game wants this estimation for
    /// </remarks>
    public partial class AnalyzeVRPoints : Window
    {
        #region class: Snapshot

        private class Snapshot
        {
            public Snapshot(RecordingSnapshot snap)
            {
                Head_Pos = ToPoint(snap.Head_Pos);
                Head_Rot = ToQuat(snap.Head_Orientation);

                Left_Pos = ToPoint(snap.Left_Pos);
                Left_Rot = ToQuat(snap.Left_Orientation);

                Right_Pos = ToPoint(snap.Right_Pos);
                Right_Rot = ToQuat(snap.Right_Orientation);
            }

            public Point3D Head_Pos { get; }
            public Quaternion Head_Rot { get; }

            public Point3D Left_Pos { get; }
            public Quaternion Left_Rot { get; }

            public Point3D Right_Pos { get; }
            public Quaternion Right_Rot { get; }

            private static Point3D ToPoint(Vec3 v)
            {
                return new Point3D(v.x, v.y, v.z);
            }
            private static Quaternion ToQuat(Vec4 v)
            {
                return new Quaternion(v.x, v.y, v.z, v.w);
            }
        }

        #endregion

        #region Declaration Section

        /// <summary>
        /// Workers that call UtilityML.DiscoverSolution_CrossoverMutate will run on this thread
        /// </summary>
        /// <remarks>
        /// If the workers ran in their own threads, they would consume the threadpool, and the game would stutter
        /// </remarks>
        private readonly RoundRobinManager _crossoverkWorkerThread = new RoundRobinManager(new StaTaskScheduler(1));

        private TrackBallRoam _trackball = null;

        private Visual3D[] _axisVisual = null;

        private Visual3D _snapshotVisual = null;
        private Snapshot[] _snapshots = null;

        private string _filename = null;

        #endregion

        #region Constructor

        public AnalyzeVRPoints()
        {
            InitializeComponent();

            // Trackball
            _trackball = new TrackBallRoam(_camera);
            _trackball.EventSource = grdViewPort;       //NOTE:  If this control doesn't have a background color set, the trackball won't see events (I think transparent is ok, just not null)
            _trackball.AllowZoomOnMouseWheel = true;
            _trackball.Mappings.AddRange(TrackBallMapping.GetPrebuilt(TrackBallMapping.PrebuiltMapping.MouseComplete_NoLeft));
            _trackball.ShouldHitTestOnOrbit = false;
        }

        #endregion

        #region Event Listeners

        private void chkAxiis_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (chkAxiis == null)
                    return;

                if (!chkAxiis.IsChecked.Value)
                {
                    if (_axisVisual != null)
                    {
                        _viewport.Children.RemoveAll(_axisVisual);
                        _axisVisual = null;
                    }

                    return;
                }

                if (_axisVisual != null)
                    return;

                _axisVisual = Debug3DWindow.GetAxisLines(3, .005);
                _viewport.Children.AddRange(_axisVisual);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void Neck_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void Load_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                string folder = System.IO.Path.Combine(UtilityCore.GetOptionsFolder(), "VRFlight");

                // Prompt for file
                var dialog = new Microsoft.Win32.OpenFileDialog()
                {
                    InitialDirectory = folder,
                    //Filter = "*.xaml|*.xml|*.*",
                    Multiselect = false,
                };

                bool? result = dialog.ShowDialog();
                if (result == null || result.Value == false)
                {
                    return;
                }

                _filename = dialog.FileName;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void IsolateNeck1_Click(object sender, RoutedEventArgs e)
        {
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                var options = new CrossoverMutate_Options<double>()
                {
                    GenerationSize = 1000,
                    MaxIterations = 50,
                    //ThreadShare = _crossoverkWorkerThread,
                    ScoreAscendDescend = new[] { false },
                    Predefined = new[]
                    {
                        new[] { .1, .1 },
                    },
                };

                var delegates = new CrossoverMutate_Delegates<double>()
                {
                    //GetNewSample = () => new double[] { StaticRandom.NextDouble(-MAX, MAX), StaticRandom.NextDouble(-MAX, MAX) },
                    GetNewSample = () => new double[] { StaticRandom.NextDouble(0, MAX), StaticRandom.NextDouble(0, MAX) },

                    GetScore = o => new[] { GetNeckDisplacementError(_snapshots, o) },

                    Mutate = o => MutateDisplacements(o, MAX),

                    FinalFound = o => ShowNeckResults(o),
                };

                UtilityML.DiscoverSolution_CrossoverMutate(delegates, options);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void IsolateNeck2_Click(object sender, RoutedEventArgs e)
        {
            const double MULT = 10000d;
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                //TODO: Figure out how to deal directly with fractions (how many bits to use)
                int bits = GeneticSharpUtil.GetChromosomeBits((MAX * MULT).ToInt_Ceiling());

                // Element0 = Neck Back
                // Element1 = Neck Down
                var chromosome = new FloatingPointChromosome(
                    new double[] { 0, 0 },
                    new double[] { MAX * MULT, MAX * MULT },
                    new int[] { bits, bits },       // The total bits used to represent each number
                    new int[] { 0, 0 });      // The number of fraction (scale or decimal) part of the number. In our case we will not use any

                var population = new Population(72, 144, chromosome);

                var fitness = new FuncFitness(c =>
                {
                    double[] values = ((FloatingPointChromosome)c).ToFloatingPoints();

                    for (int cntr = 0; cntr < values.Length; cntr++)
                        values[cntr] /= MULT;       // the values are stored as integers, because I haven't figured out how many bits to use for floating point yet

                    return GetNeckDisplacementError(_snapshots, values);
                });

                //WARNING: This selection works, but population still favors high score within that returned set, haven't figured out how to change that yet
                var selection = new ErrorSelection();       // the smaller the error, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0.0;
                var winners = new List<(double, double[])>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        winners.Add(
                        (
                            latestFitness,
                            bestChromosome.ToFloatingPoints().
                                Select(o => o / MULT).
                                ToArray()
                        ));
                    }
                };

                ga.TerminationReached += (s2, e2) => ShowNeckResults(winners, 0);

                ga.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void IsolateNeck3_Click(object sender, RoutedEventArgs e)
        {
            const double MULT = 10000d;
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                //TODO: Figure out how to deal directly with fractions (how many bits to use)
                int bits = GeneticSharpUtil.GetChromosomeBits((MAX * MULT).ToInt_Ceiling());

                // Element0 = Neck Back
                // Element1 = Neck Down
                var chromosome = new FloatingPointChromosome(
                    new double[] { 0, 0 },
                    new double[] { MAX * MULT, MAX * MULT },
                    new int[] { bits, bits },       // The total bits used to represent each number
                    new int[] { 0, 0 });      // The number of fraction (scale or decimal) part of the number. In our case we will not use any

                var population = new Population(72, 144, chromosome);

                double worstScore = MAX * Math.Sqrt(2);
                worstScore += MAX;      // add a bit to be safe

                var fitness = new FuncFitness(c =>
                {
                    double[] values = ((FloatingPointChromosome)c).ToFloatingPoints();

                    for (int cntr = 0; cntr < values.Length; cntr++)
                        values[cntr] /= MULT;       // the values are stored as integers, because I haven't figured out how many bits to use for floating point yet

                    return worstScore - GetNeckDisplacementError(_snapshots, values);       // subtracting because this needs to return a top score when error is zero
                });

                var selection = new EliteSelection();       // the higher the score, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0.0;
                var winners = new List<(double, double[])>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        winners.Add(
                        (
                            latestFitness,
                            bestChromosome.ToFloatingPoints().
                                Select(o => o / MULT).
                                ToArray()
                        ));
                    }
                };

                ga.TerminationReached += (s2, e2) => ShowNeckResults(winners, worstScore);

                ga.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Private Methods

        private void LoadFile()
        {
            if (_filename == null || !System.IO.File.Exists(_filename))
                return;






            //TODO: Instead of guessing with textboxes, use ML to find the values with the least neck variance
            if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                neckBack = 0d;

            if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                neckDown = 0d;







            lblFilename.Content = System.IO.Path.GetFileName(_filename);

            string jsonString = System.IO.File.ReadAllText(_filename);

            SnapshotSet snapshot = JsonSerializer.Deserialize<SnapshotSet>(jsonString);

            var transformed = snapshot?.Snapshots?.
                Select(o => new Snapshot(o)).
                ToArray();

            Clear();
            Show(transformed, neckBack, neckDown);
            AnalyzePoints(transformed, neckBack, neckDown);
        }

        private void Clear()
        {
            if (_snapshotVisual != null)
            {
                _viewport.Children.Remove(_snapshotVisual);
                _snapshotVisual = null;
            }

            _snapshots = null;
        }
        private void Show(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            var mat = GetMaterials();

            Model3DGroup modelGroup = new Model3DGroup();

            foreach (var snapshot in snapshots)
            {
                AddDot(modelGroup, snapshot.Head_Pos, mat.head);
                AddDot(modelGroup, snapshot.Left_Pos, mat.left);
                AddDot(modelGroup, snapshot.Right_Pos, mat.right);

                AddNeckDot(modelGroup, snapshot.Head_Pos, snapshot.Head_Rot, mat.neck, neckBack, neckDown);
            }

            Visual3D visual = new ModelVisual3D
            {
                Content = modelGroup,
            };

            _snapshotVisual = visual;
            _viewport.Children.Add(visual);

            _snapshots = snapshots;
        }

        private void AddDot(Model3DGroup modelGroup, Point3D pos, Material mat)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(.02, 1, true);

            model.Transform = new TranslateTransform3D(pos.ToVector());

            modelGroup.Children.Add(model);
        }
        private void AddNeckDot(Model3DGroup modelGroup, Point3D pos, Quaternion rot, Material mat, double neckBack, double neckDown)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(.01, 1, true);

            Point3D finalPos = GetNeckPosition(pos, rot, neckBack, neckDown);

            model.Transform = new TranslateTransform3D(finalPos.ToVector());

            modelGroup.Children.Add(model);
        }

        private static (Material head, Material left, Material right, Material neck) GetMaterials()
        {
            MaterialGroup head = new MaterialGroup();
            head.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("92F32C")));
            //head.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex(""), ));

            MaterialGroup left = new MaterialGroup();
            left.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("269BAB")));
            left.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("503E7B"), 1));

            MaterialGroup right = new MaterialGroup();
            right.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("AB4726")));
            right.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("7B783E"), 1));

            MaterialGroup neck = new MaterialGroup();
            neck.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("EEE")));
            neck.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("FFF"), 4));

            return (head, left, right, neck);
        }

        private void AnalyzePoints(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            StringBuilder report = new StringBuilder();

            var headAABB = Math3D.GetAABB(snapshots.Select(o => o.Head_Pos));

            report.AppendLine("Head AABB");
            report.AppendLine($"x: {(headAABB.max.X - headAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(headAABB.max.Y - headAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(headAABB.max.Z - headAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var leftAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Left AABB");
            report.AppendLine($"x: {(leftAABB.max.X - leftAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(leftAABB.max.Y - leftAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(leftAABB.max.Z - leftAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var rightAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Right AABB");
            report.AppendLine($"x: {(rightAABB.max.X - rightAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(rightAABB.max.Y - rightAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(rightAABB.max.Z - rightAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            double error = GetNeckDisplacementError(snapshots, new[] { neckBack, neckDown });
            report.AppendLine($"neck err: {error.ToStringSignificantDigits(3)}");

            lblStats.Text = report.ToString();
        }

        private static Point3D GetNeckPosition(Point3D headPos, Quaternion headRot, double neckBack, double neckDown)
        {
            Vector3D up = headRot.GetRotatedVector(new Vector3D(0, 1, 0));
            Vector3D forword = headRot.GetRotatedVector(new Vector3D(0, 0, 1));

            Point3D finalPos = headPos;
            finalPos -= forword * neckBack;
            finalPos -= up * neckDown;

            return finalPos;
        }

        private static double GetNeckDisplacementError(Snapshot[] snapshots, double[] settings)
        {
            Point3D[] necks = snapshots.
                Select(o => GetNeckPosition(o.Head_Pos, o.Head_Rot, settings[0], settings[1])).
                ToArray();

            Point3D center = Math3D.GetCenter(necks);

            double[] distances = necks.
                Select(o => (o - center).Length).
                ToArray();

            var avg_stddev = Math1D.Get_Average_StandardDeviation(distances);

            //TODO: May want to weight it using standard deviation
            return avg_stddev.avg;
        }
        private static double[] MutateDisplacements(double[] settings, double max)
        {
            double[] retVal = settings.ToArray();

            int index = StaticRandom.Next(settings.Length);

            retVal[index] = Math.Clamp(StaticRandom.NextPercent(retVal[index], .1), -max, max);

            return retVal;
        }
        private void ShowNeckResults(CrossoverMutate_Result<double> result)
        {
            Debug3DWindow window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(result.History.Select(o => o[0]).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {result.Score[0]}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", result.Item[0], result.Item[1]);
        }
        private void ShowNeckResults(List<(double, double[])> log, double worstScore)
        {
            Debug3DWindow window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(log.Select(o => worstScore - o.Item1).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {worstScore - log[^1].Item1}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", log[^1].Item2[0], log[^1].Item2[1]);
        }

        #endregion
    }

    #region classes: serialized

    [Serializable]
    public class SnapshotSet
    {
        public RecordingSnapshot[] Snapshots { get; set; }
    }

    [Serializable]
    public class RecordingSnapshot
    {
        public Vec3 Head_Pos { get; set; }
        public Vec4 Head_Orientation { get; set; }

        public Vec3 Left_Pos { get; set; }
        public Vec4 Left_Orientation { get; set; }

        public Vec3 Right_Pos { get; set; }
        public Vec4 Right_Orientation { get; set; }
    }

    [Serializable]
    public class Vec3
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
    }

    [Serializable]
    public class Vec4
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
        public float w { get; set; }
    }

    #endregion
}
