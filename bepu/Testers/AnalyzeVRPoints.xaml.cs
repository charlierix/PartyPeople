using Game.Core;
using Game.Core.Threads;
using Game.Math_WPF.Mathematics;
using Game.Math_WPF.WPF;
using Game.Math_WPF.WPF.Controls3D;
using Game.ML;
using GeneticSharp.Domain;
using GeneticSharp.Domain.Chromosomes;
using GeneticSharp.Domain.Crossovers;
using GeneticSharp.Domain.Fitnesses;
using GeneticSharp.Domain.Mutations;
using GeneticSharp.Domain.Populations;
using GeneticSharp.Domain.Selections;
using GeneticSharp.Domain.Terminations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Shapes;

namespace Game.Bepu.Testers
{
    /// <summary>
    /// This looks at data generated by vr head and hands
    /// </summary>
    /// <remarks>
    /// It's difficult to find solutions that infer the body skeleton
    /// 
    /// Here's one
    /// https://github.com/JamesBear/vive_ik_demo
    /// 
    /// The head tracker sits in front of the face, so the first step is coming up with a good estimate for
    /// the location of the neck
    /// 
    /// From there, it might be useful to estimate the locations of the shoulders.  I guess it depends what
    /// the game wants this estimation for
    /// </remarks>
    public partial class AnalyzeVRPoints : Window
    {
        #region class: Snapshot

        private class Snapshot
        {
            public Snapshot(RecordingSnapshot snap)
            {
                Head_Pos = ToPoint(snap.Head_Pos);
                Head_Rot = ToQuat(snap.Head_Orientation);

                Left_Pos = ToPoint(snap.Left_Pos);
                Left_Rot = ToQuat(snap.Left_Orientation);

                Right_Pos = ToPoint(snap.Right_Pos);
                Right_Rot = ToQuat(snap.Right_Orientation);
            }

            public Point3D Head_Pos { get; }
            public Quaternion Head_Rot { get; }

            public Point3D Left_Pos { get; }
            public Quaternion Left_Rot { get; }

            public Point3D Right_Pos { get; }
            public Quaternion Right_Rot { get; }

            public Point3D GetNeckPosition(double neckBack, double neckDown)
            {
                Vector3D up = Head_Rot.GetRotatedVector(new Vector3D(0, 1, 0));
                Vector3D forword = Head_Rot.GetRotatedVector(new Vector3D(0, 0, 1));

                Point3D finalPos = Head_Pos;
                finalPos -= forword * neckBack;
                finalPos -= up * neckDown;

                return finalPos;
            }

            private static Point3D ToPoint(Vec3 v)
            {
                return new Point3D(v.x, v.y, v.z);
            }
            private static Quaternion ToQuat(Vec4 v)
            {
                return new Quaternion(v.x, v.y, v.z, v.w);
            }
        }

        #endregion

        #region Declaration Section

        private const double DOTRADIUS = .02;
        private const string COLOR_LEFT = "269BAB";
        private const string COLOR_RIGHT = "AB4726";

        /// <summary>
        /// Workers that call UtilityML.DiscoverSolution_CrossoverMutate will run on this thread
        /// </summary>
        /// <remarks>
        /// If the workers ran in their own threads, they would consume the threadpool, and the game would stutter
        /// </remarks>
        private readonly RoundRobinManager _crossoverkWorkerThread = new RoundRobinManager(new StaTaskScheduler(1));

        private TrackBallRoam _trackball = null;

        private Visual3D[] _axisVisual = null;

        private List<Visual3D> _visuals = new List<Visual3D>();
        private Snapshot[] _snapshots = null;

        private string[] _filenames = null;

        private bool _initialized = false;

        #endregion

        #region Constructor

        public AnalyzeVRPoints()
        {
            InitializeComponent();

            // Trackball
            _trackball = new TrackBallRoam(_camera);
            _trackball.EventSource = grdViewPort;       //NOTE:  If this control doesn't have a background color set, the trackball won't see events (I think transparent is ok, just not null)
            _trackball.AllowZoomOnMouseWheel = true;
            _trackball.Mappings.AddRange(TrackBallMapping.GetPrebuilt(TrackBallMapping.PrebuiltMapping.MouseComplete_NoLeft));
            _trackball.ShouldHitTestOnOrbit = false;
            _trackball.MouseWheelScale *= .3;

            _initialized = true;

            chkAxiis_Checked(this, new RoutedEventArgs());
        }

        #endregion

        #region Event Listeners

        private void chkAxiis_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                if (!chkAxiis.IsChecked.Value)
                {
                    if (_axisVisual != null)
                    {
                        _viewport.Children.RemoveAll(_axisVisual);
                        _axisVisual = null;
                    }

                    return;
                }

                if (_axisVisual != null)
                    return;

                _axisVisual = Debug3DWindow.GetAxisLines(3, .005);
                _viewport.Children.AddRange(_axisVisual);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void chCenterOnNeck_Checked(object sender, RoutedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void Neck_TextChanged(object sender, TextChangedEventArgs e)
        {
            try
            {
                if (!_initialized)
                    return;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void Load_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                string folder = System.IO.Path.Combine(UtilityCore.GetOptionsFolder(), "VRFlight");

                // Prompt for file
                var dialog = new Microsoft.Win32.OpenFileDialog()
                {
                    InitialDirectory = folder,
                    //Filter = "*.xaml|*.xml|*.*",
                    Multiselect = true,
                };

                bool? result = dialog.ShowDialog();
                if (result == null || result.Value == false)
                {
                    return;
                }

                _filenames = dialog.FileNames;

                LoadFile();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void IsolateNeck1_Click(object sender, RoutedEventArgs e)
        {
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                var options = new CrossoverMutate_Options<double>()
                {
                    GenerationSize = 1000,
                    MaxIterations = 50,
                    //ThreadShare = _crossoverkWorkerThread,
                    ScoreAscendDescend = new[] { false },
                    Predefined = new[]
                    {
                        new[] { .1, .1 },
                    },
                };

                var delegates = new CrossoverMutate_Delegates<double>()
                {
                    //GetNewSample = () => new double[] { StaticRandom.NextDouble(-MAX, MAX), StaticRandom.NextDouble(-MAX, MAX) },
                    GetNewSample = () => new double[] { StaticRandom.NextDouble(0, MAX), StaticRandom.NextDouble(0, MAX) },

                    GetScore = o => new[] { GetNeckDisplacementError(_snapshots, o) },

                    Mutate = o => MutateDisplacements(o, MAX),

                    FinalFound = o => ShowNeckResults(o),
                };

                UtilityML.DiscoverSolution_CrossoverMutate(delegates, options);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void IsolateNeck2_Click(object sender, RoutedEventArgs e)
        {
            const double MULT = 10000d;
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                //TODO: Figure out how to deal directly with fractions (how many bits to use)
                int bits = GeneticSharpUtil.GetChromosomeBits((MAX * MULT).ToInt_Ceiling());

                // Element0 = Neck Back
                // Element1 = Neck Down
                var chromosome = new FloatingPointChromosome(
                    new double[] { 0, 0 },
                    new double[] { MAX * MULT, MAX * MULT },
                    new int[] { bits, bits },       // The total bits used to represent each number
                    new int[] { 0, 0 });      // The number of fraction (scale or decimal) part of the number. In our case we will not use any

                var population = new Population(72, 144, chromosome);

                var fitness = new FuncFitness(c =>
                {
                    double[] values = ((FloatingPointChromosome)c).ToFloatingPoints();

                    for (int cntr = 0; cntr < values.Length; cntr++)
                        values[cntr] /= MULT;       // the values are stored as integers, because I haven't figured out how many bits to use for floating point yet

                    return GetNeckDisplacementError(_snapshots, values);
                });

                //WARNING: This selection works, but population still favors high score within that returned set, haven't figured out how to change that yet
                var selection = new ErrorSelection();       // the smaller the error, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0.0;
                var winners = new List<(double, double[])>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        winners.Add(
                        (
                            latestFitness,
                            bestChromosome.ToFloatingPoints().
                                Select(o => o / MULT).
                                ToArray()
                        ));
                    }
                };

                ga.TerminationReached += (s2, e2) => ShowNeckResults(winners, 0);

                ga.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void IsolateNeck3_Click(object sender, RoutedEventArgs e)
        {
            const double MULT = 10000d;
            const double MAX = .5d;

            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                lblNeckResults.Text = "working...";

                //TODO: Figure out how to deal directly with fractions (how many bits to use)
                int bits = GeneticSharpUtil.GetChromosomeBits((MAX * MULT).ToInt_Ceiling());

                // Element0 = Neck Back
                // Element1 = Neck Down
                var chromosome = new FloatingPointChromosome(
                    new double[] { 0, 0 },
                    new double[] { MAX * MULT, MAX * MULT },
                    new int[] { bits, bits },       // The total bits used to represent each number
                    new int[] { 0, 0 });      // The number of fraction (scale or decimal) part of the number. In our case we will not use any

                var population = new Population(72, 144, chromosome);

                double worstScore = MAX * Math.Sqrt(2);
                worstScore += MAX;      // add a bit to be safe

                var fitness = new FuncFitness(c =>
                {
                    double[] values = ((FloatingPointChromosome)c).ToFloatingPoints();

                    for (int cntr = 0; cntr < values.Length; cntr++)
                        values[cntr] /= MULT;       // the values are stored as integers, because I haven't figured out how many bits to use for floating point yet

                    return worstScore - GetNeckDisplacementError(_snapshots, values);       // subtracting because this needs to return a top score when error is zero
                });

                var selection = new EliteSelection();       // the higher the score, the better

                var crossover = new UniformCrossover(0.5f);     // .5 will pull half from each parent

                var mutation = new FlipBitMutation();       // FloatingPointChromosome inherits from BinaryChromosomeBase, which is a series of bits.  This mutator will flip random bits

                var termination = new FitnessStagnationTermination(144);        // keeps going until it generates the same winner this many generations in a row

                var ga = new GeneticAlgorithm(population, fitness, selection, crossover, mutation)
                {
                    Termination = termination,
                };

                double latestFitness = 0.0;
                var winners = new List<(double, double[])>();

                ga.GenerationRan += (s1, e1) =>
                {
                    var bestChromosome = ga.BestChromosome as FloatingPointChromosome;
                    double bestFitness = bestChromosome.Fitness.Value;

                    if (bestFitness != latestFitness)
                    {
                        latestFitness = bestFitness;
                        winners.Add(
                        (
                            latestFitness,
                            bestChromosome.ToFloatingPoints().
                                Select(o => o / MULT).
                                ToArray()
                        ));
                    }
                };

                ga.TerminationReached += (s2, e2) => ShowNeckResults(winners, worstScore);

                ga.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        //TODO: Each hand needs its own plane
        private void CalculatePlane1_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                bool centerOnNeck = chkCenterOnNeck.IsChecked.Value;

                string left = CalculateShowPlane(_snapshots.Select(o => o.Left_Pos), UtilityWPF.ColorFromHex(COLOR_LEFT), centerOnNeck);
                string right = CalculateShowPlane(_snapshots.Select(o => o.Right_Pos), UtilityWPF.ColorFromHex(COLOR_RIGHT), centerOnNeck);

                lblPlane.Text = $"Left\r\n{left}\r\nRight{right}";
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void CalculatePlane2_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_snapshots == null)
                {
                    MessageBox.Show("Need to load snapshots first", Title, MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                Point3D[] points = _snapshots.
                    Select(o => o.Left_Pos).
                    ToArray();

                var planes = Enumerable.Range(0, 144).
                    Select(o =>
                    {
                        var plane = Math2D.GetPlane_Average(points);

                        if (Vector3D.DotProduct(plane.Normal, new Vector3D(0, 1, 0)) < 0)
                            return new Triangle_wpf(plane.Point0, plane.Point2, plane.Point1);      // reversing the vertex order
                        else
                            return plane;
                    }).
                    ToArray();

                Vector3D avgNormal = Math3D.GetAverage(planes.Select(o => o.NormalUnit));

                var dots = planes.
                    Select(o => new
                    {
                        plane = o,
                        dot = Vector3D.DotProduct(o.NormalUnit, avgNormal),
                    }).
                    OrderBy(o => o.dot).
                    ToArray();


                foreach (var plane in dots.Take(1))
                {
                    ImprovePlane(plane.plane, points, 12);
                }

                //foreach (var plane in dots.TakeLast(2))
                //{
                //    ImprovePlane(plane.plane, points);
                //}
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void CalculatePlane3_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                // 2 failed because the corrected plane didn't try to minimize the sum of the distance from the plane

                // it would be kind of fun to try a genetic algorithm, even though it's probably not optimal

                // the code in math2d chooses completely random triangles and averages them with equal weight, but should really
                // give a lot more importance to the largest triangles, or throw out tiny triangles completely (based on the length
                // of the normals)
                //
                // but what's a good way to choose the points that are likely to give large areas?
                //    once one vertex is chosen, choose another that is at least X away?
                //    choose a bunch of random like it currently does, look at the distribution of areas, decide on a threshold, keep choosing until a count is met?






            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), Title, MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region Private Methods

        private void LoadFile()
        {
            if (_filenames == null || _filenames.Length == 0 || _filenames.Any(o => !System.IO.File.Exists(o)))
                return;

            if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                neckBack = 0d;

            if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                neckDown = 0d;

            lblFilename.Content = _filenames.
                Select(o => System.IO.Path.GetFileName(o)).
                ToJoin("\r\n");


            var snapshots = new List<Snapshot>();

            foreach (string filename in _filenames)
            {
                string jsonString = System.IO.File.ReadAllText(filename);

                SnapshotSet snapshot = JsonSerializer.Deserialize<SnapshotSet>(jsonString);

                snapshots.AddRange(snapshot?.Snapshots?.Select(o => new Snapshot(o)));
            }

            Clear();
            Show(snapshots.ToArray(), neckBack, neckDown, chkCenterOnNeck.IsChecked.Value);
            AnalyzePoints(snapshots.ToArray(), neckBack, neckDown);
        }

        private void Clear()
        {
            _viewport.Children.RemoveAll(_visuals);
            _visuals.Clear();

            _snapshots = null;
        }
        private void Show(Snapshot[] snapshots, double neckBack, double neckDown, bool handsOffNeck)
        {
            var mat = GetMaterials();

            Model3DGroup modelGroup = new Model3DGroup();

            Point3D avgNeck = handsOffNeck ?
                Math3D.GetCenter(snapshots.Select(o => o.GetNeckPosition(neckBack, neckDown))) :
                new Point3D();

            foreach (var snapshot in snapshots)
            {
                Point3D neckPos = snapshot.GetNeckPosition(neckBack, neckDown);

                if (handsOffNeck)
                {
                    AddDot(modelGroup, avgNeck + (snapshot.Head_Pos - neckPos), mat.head);
                    AddDot(modelGroup, avgNeck + (snapshot.Left_Pos - neckPos), mat.left);
                    AddDot(modelGroup, avgNeck + (snapshot.Right_Pos - neckPos), mat.right);
                    AddDot(modelGroup, avgNeck + (neckPos - neckPos), mat.neck, .5);
                }
                else
                {
                    AddDot(modelGroup, snapshot.Head_Pos, mat.head);
                    AddDot(modelGroup, snapshot.Left_Pos, mat.left);
                    AddDot(modelGroup, snapshot.Right_Pos, mat.right);
                    AddDot(modelGroup, neckPos, mat.neck, .5);
                }
            }

            Visual3D visual = new ModelVisual3D
            {
                Content = modelGroup,
            };

            _visuals.Add(visual);
            _viewport.Children.Add(visual);

            _snapshots = snapshots;
        }

        private void AddDot(Model3DGroup modelGroup, Point3D pos, Material mat, double radiusPercent = 1)
        {
            GeometryModel3D model = new GeometryModel3D();
            model.Material = mat;
            model.BackMaterial = mat;

            model.Geometry = UtilityWPF.GetSphere_Ico(DOTRADIUS * radiusPercent, 1, true);

            model.Transform = new TranslateTransform3D(pos.ToVector());

            modelGroup.Children.Add(model);
        }

        private static (Material head, Material left, Material right, Material neck) GetMaterials()
        {
            MaterialGroup head = new MaterialGroup();
            head.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("92F32C")));
            //head.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex(""), ));

            MaterialGroup left = new MaterialGroup();
            left.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex(COLOR_LEFT)));
            left.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("503E7B"), 1));

            MaterialGroup right = new MaterialGroup();
            right.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex(COLOR_RIGHT)));
            right.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("7B783E"), 1));

            MaterialGroup neck = new MaterialGroup();
            neck.Children.Add(new DiffuseMaterial(UtilityWPF.BrushFromHex("EEE")));
            neck.Children.Add(new SpecularMaterial(UtilityWPF.BrushFromHex("FFF"), 4));

            return (head, left, right, neck);
        }

        private void AnalyzePoints(Snapshot[] snapshots, double neckBack, double neckDown)
        {
            StringBuilder report = new StringBuilder();

            var headAABB = Math3D.GetAABB(snapshots.Select(o => o.Head_Pos));

            report.AppendLine("Head AABB");
            report.AppendLine($"x: {(headAABB.max.X - headAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(headAABB.max.Y - headAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(headAABB.max.Z - headAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var leftAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Left AABB");
            report.AppendLine($"x: {(leftAABB.max.X - leftAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(leftAABB.max.Y - leftAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(leftAABB.max.Z - leftAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            var rightAABB = Math3D.GetAABB(snapshots.Select(o => o.Left_Pos));

            report.AppendLine("Right AABB");
            report.AppendLine($"x: {(rightAABB.max.X - rightAABB.min.X).ToStringSignificantDigits(3)}");
            report.AppendLine($"y: {(rightAABB.max.Y - rightAABB.min.Y).ToStringSignificantDigits(3)}");
            report.AppendLine($"z: {(rightAABB.max.Z - rightAABB.min.Z).ToStringSignificantDigits(3)}");

            report.AppendLine();

            double error = GetNeckDisplacementError(snapshots, new[] { neckBack, neckDown });
            report.AppendLine($"neck err: {error.ToStringSignificantDigits(3)}");

            lblStats.Text = report.ToString();
        }

        private static double GetNeckDisplacementError(Snapshot[] snapshots, double[] settings)
        {
            Point3D[] necks = snapshots.
                Select(o => o.GetNeckPosition(settings[0], settings[1])).
                ToArray();

            Point3D center = Math3D.GetCenter(necks);

            double[] distances = necks.
                Select(o => (o - center).Length).
                ToArray();

            var avg_stddev = Math1D.Get_Average_StandardDeviation(distances);

            //TODO: May want to weight it using standard deviation
            return avg_stddev.avg;
        }
        private static double[] MutateDisplacements(double[] settings, double max)
        {
            double[] retVal = settings.ToArray();

            int index = StaticRandom.Next(settings.Length);

            retVal[index] = Math.Clamp(StaticRandom.NextPercent(retVal[index], .1), -max, max);

            return retVal;
        }
        private void ShowNeckResults(CrossoverMutate_Result<double> result)
        {
            Debug3DWindow window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(result.History.Select(o => o[0]).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {result.Score[0]}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", result.Item[0], result.Item[1]);
        }
        private void ShowNeckResults(List<(double, double[])> log, double worstScore)
        {
            Debug3DWindow window = new Debug3DWindow();

            var graph = Debug3DWindow.GetGraph(log.Select(o => worstScore - o.Item1).ToArray());
            window.AddGraph(graph, new Point3D(), 1);

            window.AddText($"score: {worstScore - log[^1].Item1}");

            window.Show();



            lblNeckResults.Text = string.Format("neckBack: {0}\r\nneckDown: {1}", log[^1].Item2[0], log[^1].Item2[1]);
        }

        private string CalculateShowPlane(IEnumerable<Point3D> points, Color color, bool centerOnNeck)
        {
            // Get Points
            Point3D[] points1 = null;
            if (centerOnNeck)
            {
                if (!double.TryParse(txtNeckBack.Text, out double neckBack))
                    neckBack = 0d;

                if (!double.TryParse(txtNeckDown.Text, out double neckDown))
                    neckDown = 0d;

                Point3D avgNeck = Math3D.GetCenter(_snapshots.Select(o => o.GetNeckPosition(neckBack, neckDown)));

                points1 = points.
                    Select((o, i) =>
                    {
                        Point3D neckPos = _snapshots[i].GetNeckPosition(neckBack, neckDown);
                        return avgNeck + (o - neckPos);
                    }).
                    ToArray();
            }
            else
            {
                points1 = points.ToArray();
            }

            // Show Plane
            var plane = Math2D.GetPlane_Average(points1);
            Point3D pointOnPlane = Math3D.GetClosestPoint_Plane_Point(plane, Math3D.GetCenter(points1));

            Visual3D visual = Debug3DWindow.GetPlane(plane, 3, color, center: pointOnPlane);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            visual = Debug3DWindow.GetDot(pointOnPlane, DOTRADIUS * 1.5, color);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            visual = Debug3DWindow.GetLine(pointOnPlane, pointOnPlane + plane.NormalUnit, DOTRADIUS / 3, color);
            _viewport.Children.Add(visual);
            _visuals.Add(visual);

            // Report
            StringBuilder report = new StringBuilder();
            report.AppendLine($"Normal: {plane.NormalUnit.ToStringSignificantDigits(3)}");
            report.AppendLine($"Point: {pointOnPlane.ToStringSignificantDigits(3)}");

            return report.ToString();
        }

        private static ITriangle_wpf ImprovePlane(ITriangle_wpf plane, Point3D[] points, int countdown)
        {
            var pointDistances = points.
                Select(o => new
                {
                    point = o,
                    dist = Math.Abs(Math3D.DistanceFromPlane(plane, o)),
                }).
                ToArray();

            double maxDist = pointDistances.Max(o => o.dist);

            Point3D center = Math3D.GetCenter(points);

            var sizes = Debug3DWindow.GetDrawSizes(Math3D.GetAABB(points).max.ToVector3().Length());

            #region draw initial

            Debug3DWindow window = new Debug3DWindow()
            {
                Title = countdown.ToString(),
                Width = 1000,
                Height = 1000,
            };

            window.AddAxisLines(2, sizes.line);

            foreach (var point in pointDistances)
            {
                double percent = UtilityMath.GetScaledValue_Capped(0, 1, 0, maxDist, point.dist);
                Color color = UtilityWPF.AlphaBlend(Colors.Red, Colors.White, percent);

                window.AddDot(point.point, sizes.dot, color);
            }

            window.AddDot(center, sizes.dot, Colors.Black);

            window.AddPlane(plane, 2, Colors.Coral);

            window.Show();

            #endregion

            var offsets = points.
                Select(o =>
                {
                    Point3D planePoint = Math3D.GetClosestPoint_Plane_Point(plane, o);
                    //Quaternion rotation = Math3D.GetRotation(o - center, planePoint - center);
                    Quaternion rotation = Math3D.GetRotation(o - center, planePoint - center);

                    return new
                    {
                        point = o,
                        planePoint,
                        //rotation = rotation.ToUnit(),
                        rotation,
                    };
                }).
                ToArray();

            Quaternion average = Math3D.GetAverage(offsets.Select(o => o.rotation).ToArray());

            Vector3D planeNormal = plane.NormalUnit;

            #region draw quats

            window = new Debug3DWindow()
            {
                Title = "Rotations",
                Width = 1000,
                Height = 1000,
            };

            window.AddLines
            (
                offsets.
                    Select(o =>
                    (
                        center,
                        center + o.rotation.GetRotatedVector(planeNormal)
                    )),
                sizes.line,
                Colors.Black
            );

            window.AddLine(center, center + average.GetRotatedVector(planeNormal * 1.1), sizes.line, Colors.White);

            window.AddLine(center, center + planeNormal * 1.1, sizes.line, Colors.Red);

            //window.Show();

            #endregion

            var plane2 = Math3D.GetPlane(center, average.GetRotatedVector(plane.NormalUnit));

            return countdown > 0 ?
                ImprovePlane(plane2, points, countdown - 1) :
                plane2;
        }

        #endregion
    }

    #region classes: serialized

    [Serializable]
    public class SnapshotSet
    {
        public RecordingSnapshot[] Snapshots { get; set; }
    }

    [Serializable]
    public class RecordingSnapshot
    {
        public Vec3 Head_Pos { get; set; }
        public Vec4 Head_Orientation { get; set; }

        public Vec3 Left_Pos { get; set; }
        public Vec4 Left_Orientation { get; set; }

        public Vec3 Right_Pos { get; set; }
        public Vec4 Right_Orientation { get; set; }
    }

    [Serializable]
    public class Vec3
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
    }

    [Serializable]
    public class Vec4
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }
        public float w { get; set; }
    }

    #endregion
}
